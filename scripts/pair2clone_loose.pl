#!/lustre1/zeminz_pkuhpc/01.bin/perl-5.24/bin/perl
use strict;
use warnings;
use Getopt::Long;
#use Data::Dumper;

my $usage = "Usage:  perl  $0  --min_a 0  --min_b 0   <Pair>   >Out\n";
my ($min_a, $min_b) = (0, 0);
GetOptions( 
	"min_a:i" => \$min_a, 
	"min_b:i" => \$min_b
);

die $usage if @ARGV  !=1;


### Data Structure
# %pair        ->  patient  ->  PairID    -> 'CDR3.AB'
#                                         -> 'VDJtype'
#                                         -> 'cells'   -> (array)
#
# %cell2clone  ->  cellID   ->  cloneID
# 
# %clone       ->  patient  ->  cloneID -> 'VDJtype'
#                           ->  cloneID -> 'Cells'  -> CellID (use only key)
#                           ->  cloneID -> 'Pairs'  -> PairID -> 'count'
#                                                             -> 'CDR3.AB'


### read 'panC.VDJpair.txt' which generated by 'vdj2pair.pl'
my %pair = ();
open INV, $ARGV[0];
while (<INV>){
	#  0       1        2        3       4             5        6
	# pairID  CDR3.AB  VDJtype  cellID  patientID     nUMI.A   nUMI.B
	next if $.==1;
	chomp;
	my @t = split /\t/;
	next unless ($t[5]>=$min_a && $t[6]>=$min_b);
	$pair{$t[4]}{$t[0]}{'CDR3.AB'} = $t[1];
	$pair{$t[4]}{$t[0]}{'VDJtype'} = $t[2];
	push @{$pair{$t[4]}{$t[0]}{'cells'}}, $t[3];
}
close INV;

#print Dumper \%pair; exit;


#### assign clone
my %clone = ();

foreach my $patient (sort keys %pair){
	my $clone_count = 0;
	foreach my $key (sort keys %{$pair{$patient}}){
		next if (! exists $pair{$patient}{$key});  # delete during process
		$clone_count++;
		my $cloneID = sprintf("%s_C%.6d", $patient, $clone_count);
		my $VDJtype = $pair{$patient}{$key}{'VDJtype'};
		## initiate: save the first key's info and delete it
		my %Cells = ();
		$Cells{$_} = 1 foreach @{$pair{$patient}{$key}{'cells'}};
		my %Pairs = ();
		$Pairs{$key}{'count'} = @{$pair{$patient}{$key}{'cells'}};
		$Pairs{$key}{'CDR3.AB'} = $pair{$patient}{$key}{'CDR3.AB'};
		delete $pair{$patient}{$key};
		# Recursion scan
		Classify( \%{$pair{$patient}}, \%Cells, \%Pairs );
		$clone{$patient}{$cloneID}{'VDJtype'} = $VDJtype;
		$clone{$patient}{$cloneID}{'Cells'} = \%Cells;
		$clone{$patient}{$cloneID}{'Pairs'} = \%Pairs;
	}
}

sub Classify {
	my ( $data_ref, $Cells_ref, $Pairs_ref) = @_;
	my $finish = 1;
	foreach my $this_key (sort keys %{$data_ref}){
		my $have = 0;
		foreach my $this_cell (@{$data_ref->{$this_key}{'cells'}}){
			if (exists $Cells_ref->{$this_cell}){
				$have = 1;
				$finish = 0;
			}
		}
		if ($have){
			## save info and delete
			$Cells_ref->{$_} = 1 foreach @{$data_ref->{$this_key}{'cells'}};
			$Pairs_ref->{$this_key}{'count'} = @{$data_ref->{$this_key}{'cells'}};
			$Pairs_ref->{$this_key}{'CDR3.AB'} = $data_ref->{$this_key}{'CDR3.AB'};
			delete $data_ref->{$this_key};
		}
	}
	## re-sub job until '$finish=1' which means no overlap in this turn
	if ($finish){
		return;
	}else{
		Classify( $data_ref, $Cells_ref, $Pairs_ref );
	}
}

#print Dumper \%clone; exit;


#### Output
print "cloneID\tcloneType\tVDJtype\tpairIDs\tCDR3.ABs\tFreqs\tCells\n";
foreach my $patient( sort keys %clone ){
	foreach my $cloneID (sort keys %{$clone{$patient}}){
		my $VDJtype = $clone{$patient}{$cloneID}{'VDJtype'};
		my @cells = sort keys %{$clone{$patient}{$cloneID}{'Cells'}};
		my $cloneSize = @cells;
		my $cloneType = $cloneSize >1 ? "Clonal": "NonClonal";
		my @pairs = ();
		my @CDR3s = ();
		my @Freqs = ();
		my %pairs_hash = %{$clone{$patient}{$cloneID}{'Pairs'}};
		foreach my $pairID (sort {$pairs_hash{$b}{'count'} <=> $pairs_hash{$a}{'count'}} keys %pairs_hash){
			push @pairs, $pairID;
			push @CDR3s, $pairs_hash{$pairID}{'CDR3.AB'};
			push @Freqs, $pairs_hash{$pairID}{'count'};
		}
		$cloneID = "$cloneID:$cloneSize";
		print "$cloneID\t$cloneType\t$VDJtype\t" . join(",",@pairs) . "\t" . join(",",@CDR3s) . "\t" . join(",",@Freqs) . "\t" . join(",",@cells) . "\n";
	}
}
